---
title: 'Opinions: Be a Developer, Not a Programmer'
subtitle: 'Part II'
category: Software Development
tags:
- programming
- php
- design
- kohana
- framework
- agile
- developer
- SCRUM
- Web application
comments:
- id: 91
  author: sdogi
  author_email: sdogi@bushiq.com
  author_url: ''
  date: '2011-10-25 17:00:48 +0300'
  date_gmt: '2011-10-25 15:00:48 +0300'
  content: |-
    Not using frameworks and justifying it by saying you can gain more speed/power/women this way is actually very common problem that hits young developers.

    This sort of stubbornness is usually caused by the fact that software engineering is difficult and people are slaves to their habits. If somebody learns one programming language/framework/operating system they are usually very unlikely to look elsewhere. Specially when these people need to do some project but they have limited time.

    Sure you can get the job done without using frameworks and justify your choices and say they were the best and what not but often enough when you do objective analysis of the tools used you may find that you weren't using the best ones. Important point is to completely throw your ego and subjectivity generated by experience with certain tools and languages out of the window when doing this analysis.

    Saying frameworks are only good for small projects is completely based on such subjectivity.

    Firstly assuming that when you use a framework you are limited into doing things in a certain way that framework API forces you to is completely wrong. Frameworks are there to help you DRY and thus do things faster and better. If there are limitations in framework though then what stops you to modify framework code directly? You will be still better off than writing everything from scratch. Usually this is not even required because with most good frameworks you can overload framework classes within your own code base.

    Also if you use a framework what stops you from using optimized non-framework code for parts that require this? If you have been writing software for some time you usually know that when it comes to software speed then there are only quite few places that could be called bottlenecks. It's not like your whole software slows down because you use framework code. Dumping framework to avoid bottlenecks doesn't help but thinking up new design or rewriting critical function to be better optimized usually will. Amusingly enough people who are all about speed and write their software from scratch often enough introduce bottlenecks that wouldn't have happened if they had used a proper framework to build their product.

    Frameworks help you to be a better engineer and focus on what is really important. For example your software design(which is a creative process by the way). Who has time to repeat yourself all the time, fix bugs that don't need fixing and most importantly waste time because of bad choice and habits.

    It's ironical Kristo that you mention Twitter and Facebook in your arguments as examples where speed is important.. and I assume where things were written from scratch? Because Twitter was actually written using Ruby on Rails and probably uses bunch of other tools that they haven't written from scratch because they like to concentrate on what makes them different not optimizing stuff that doesn't matter.

    Facebook is well known for releasing it's Tornado web server framework. Also they use Hive/Hadoop, Scribe, Thrift, Boost C++ framework and probably tons of other stuff. I would dare to say that one of the reasons why Facebook is complete success when it comes to engineering is because they are using all the power they can get from frameworks.

    You can also notice that when there actually isn't a framework for what they need(usually all sorts of concurrent systems) they will develop a framework which is based on some other existing framework. Only then will they proceed with developing something new instead of writing their final product from scratch.

    When it comes to 99% of the companies though then these days when you want to start building something you usually have lots of frameworks to choose from. So all you have to do is just pick the best one for the job. Obviously this means that you have to spend time on learning the framework but when you do then you can be taken seriously in your niche.

    One very interesting piece of information about frameworks I learned is that people who know more than one or two is usually very scarce. Same probably applies to programming languages, IDE's and operating systems. When people can choose any of these then their first choice is usually by personal taste.

    What is really bad though is that when we get experienced with our choices then for some reason all want to fight against anything new or competing tools even though they might not even be that bad. It's just that we don't have enough experience with the "other" things and when we try to use them it's not as easy. This sadly gets translated to "other things" = bad and instead of learning something new and perhaps useful we start a war against it and think up bogus information to back it up.

    Always try to keep an open mind. When choosing something check for facts and honestly not selectively. Tap into other peoples experience but assess these experiences objectively. If somebody says that x is awesome then what does he mean? Is it awesome to mess around, does it maybe just look good or could it be awesome for you too?

    Only thing that matters is results. What if your results suffer because of some past decisions or reluctance to learn thanks to your ego?
- id: 92
  author: Kristo Vaher
  author_email: kristo@waher.net
  author_url: http://www.waher.net
  date: '2011-11-08 20:06:27 +0200'
  date_gmt: '2011-11-08 18:06:27 +0200'
  content: |-
    sdogi, thank you for a very detailed response. I do agree with you, I just think you misunderstood my point. It really is not that black and white.

    This is not a framework-vs-reinvent-the-wheel argument. I've developed business critical web-applications for years and I use frameworks whenever I believe it not to hamper my applications performance too much.

    But when it comes to the main, core code, then frameworks do not have to be the starting point, unless you are developing a proof of concept or a prototype. It is bound to be slower and create footprints that will cause performance issues in the long run due to it carrying code that is developed for reasons your application is not intended for.

    When it comes to 'irony' about me mentioning Twitter and Facebook, then it is interesting indeed. Except that you are a little outdated or you just missed my point. Twitter was, yes, using Ruby on Rails framework for a long time, until performance became an issue. They have now replaced majority of their code with native Scala.

    As for Facebook, Facebook is written on native PHP and without frameworks for the same reason. This includes their HipHop which was intended to get even more out of their performance due to being the most high-traffic website in the world. The rest that you mention, especially Hive/Hadoop, Scribe, Thrift and Boost C++ then those are either applications for Apache server or extensions of C++, they have nothing to do with Facebook's native software code and were not at all an issue I was talking about. This would have been more relevant if I had advocated, in any way, against the use of things like PHP or Apache extensions. But that I did not do.

    Fact remains that a native code that is built only for the specific purpose and needs of the software is always faster than the one built with a framework. Whether doing that is the right call, depends entirely on what the project needs. I do agree completely that writing on top of a framework is often quicker when it comes to development time and often more risk free, of course.

    I 'am' using a framework that my team has developed for the past few years, but a framework that is as bare-bones as possible and with as minimal footprint as possible for any new software project. As I said, it is not about whether one should reinvent the wheel or not, but saying that some known framework use is the only right way is simply shortsighted.

    All the best.
- id: 93
  author: Ando
  author_email: andoroots@yahoo.co.uk
  author_url: ''
  date: '2011-11-14 12:02:42 +0200'
  date_gmt: '2011-11-14 10:02:42 +0200'
  content: |-
    I think all three parts of the discussion could be summarized with a paragraph from Kristo's comment above:

    <blockquote>Fact remains that a native code that is built only for the specific purpose and needs of the software is always faster than the one built with a framework. Whether doing that is the right call, depends entirely on what the project needs. I do agree completely that writing on top of a framework is often quicker when it comes to development time and often more risk free, of course.</blockquote>
---
This is a continuation of the previous post, [Be a Developer, Not a Programmer Part I]({% post_url 2011/2011-09-06-be-a-developer-not-a-programmer %})".

## Ando Roots

It's true that teachers always try to teach things as they should be... at least the good ones. That's because, as with every learning, we learn things in details that later wear off. If we're told to use design pattern X then there's hope that as years go by, we fall back to design pattern M instead of all the way to A. Also consider that most professors work in the field they teach so they know of the 'real world'... at least in my applied sciences college.

Even though I haven't done any real agile development before, I don't think it's "extremely slow" because in it's heart, Scrum (as an example) is made up of iterations that allow the team quick feedback and the customer control over what to change in the next iteration. So if Twitter invents video chat and FB uses SCRUM, there's hope Facebook's own feature will be out the next week.

There are no developers who don't test their own code (or they aren't developers). Any real testing however involves writing automated test cases. Which is notoriously difficult when you work with a person who thinks it's pointless and a waste of time and breaks (my) tests constantly by modifying the code, but not the tests. Do I even dare to dream of version control when "`cp folder1 folder2`" suffices?

### Framework restrictions

There ARE restrictive frameworks out there. Some might find the rules comfortable since then it doesn't matter whose code you write/modify - you know exactly where to look for something and even if you happen upon an undocumented piece of code, you have a general idea of what's it for.

On the other hand, there are frameworks that implement a general structure such as how controllers/models are structured and then leave the rest up to you. You can and are encouraged to use the particular conventions of the framework, but you may also deviate and create your own rules. It's the same as with laws: you don't like Estonian, go east - maybe it's just right for your style. In general however, you wouldn't ever want to go all the way to the North Pole where there are no (maybe an exaggeration) rules whatsoever - rules such as "thou shall not kill" make life easier.

I approve of the style of using classes and libraries because that strips away the need to invent a triangular wheel...but on the other hand, doesn't give (for granted) you the separation and all other goodies a truer HMVC approach does.

My boss and I have long argued over placing functions in classes, his argument being that loading classes takes far more memory than including a function collection. I've never proven it, but my train of thought is that if the rest of the world - including some opinion leaders - do it and succeed in earning their monthly paycheck, it's the way to go.

What is more, computing power on small-to-medium scale web applications is not an issue anymore. I can allow for some more MB-s of memory on scalable hosting such as the Amazon cloud or Google's own Appengine. And, speaking of the real world again from an (local) Estonian company perspective, most developed application never get such an amount of traffic/usage that the issue of critical resource depletion comes up.

### Convention over Configuration

I disagree with you on the point that complicated tasks should be simplified instead of the simple/common ones. It's far more difficult to guess the particular needs of a complicated task, thus creating the restrictive rules you mentioned. Think for a second: what are the two most common actions a web application does?

Nope, think some more...

Yes! The answer is user auth (signup/login) and CRUD. If I have Kohana with it's Auth and Formo modules, I can present the user with a working prototype of a password protected memo/tweet/warehouse system within the span of half an hour - that I quite possibly whipped up while (s)he was still going over the details with the company salesman.

With Frameworks, this kind of a task is trivial. With libraries, it's not: you have to write some code (don't forget your validations!) and HTML forms, instead of creating the database and routing info and leaving the rest up to Convention over Configuration. That's great for prototyping, but also during and after the main development. Adding a new field is as simple as creating the database field and specifying validation rules.

It's important to go for speed from the start if you're building the next Twitter. It doesn't matter if you're doing a custom-built app for a company of 100 employees. This may be another trap for the impatient ones, too. The client wants results and fast. If none are given, well, there are always other willing parties, especially if you don't do Waterfall, where the contract is "signed with blood" ( - P. Leis).

A word in favor of ditching frameworks tough: you are right that if you indeed work at NASA, you DO reinvent the space shuttle, just so you could have the absolute and total knowledge and control.

### To use a framework...

Frameworks are equally important when you're building a front-end for other services, in fact I'd say that's a case where you'd want to use a Framework even more. Why? If you're not doing any complex calculations on the same machine, you have free memory; memory that the framework can use and justify it's existence. I'd say you should pass on the framework when you're building an API. THEN you need all the juice you can get since API-s usually have far bigger loads.

Speaking of reality (yeah, but we must)... You'd want to use a framework by default, unless special requirements - huge load, knowledge of the future, framework restrictions - point you the other way. You want to develop fast and present the client with a prototype early, so you can get feedback faster, so you can ship a better product. To do that, you use a framework so you don't have to tell the boss that you wrote HTML forms and created validations in the form of a series of if statements for the whole 1st day. You'd also do things the Agile way to adopt to changes fast. And when that doesn't work out, you can always Kanban and be done with it.

And no, I wouldn't stamp a developer bad just because he's not fast enough. I've seen no scalar attribute by which to grade a developer, with the exception of WTF / minute... and the opinions of developers who have to maintain the other's code in the future.

### Development - a Creative Process?

Now comes the part I dread to write, because your last point is the one I disagree with most strongly.

Writing software IS (with double underlining) a creative process. [big fat period] It's the typical way of thinking for functional programmers who look at the world like this:

> Okay, to solve this problem, I write function X and I can see that function X needs function Y and so I write function Y. Clearly, function Y must calculate the tax return so I have to look up the percentages and just code the function to return the value Z. I don't really fancy writing function Y because I don't like rinse-and-repeat, but I have to do this so I could do the same with function X.

I'm clearly exaggerating again, but without personal experience, my opinion stands.

On the other hand, I'm like this:

> Hmm...what an interesting problem! I already see three possible solutions for it. What if I asked the framework to do the calculations for X? Hmm, no, that would expose vulnerability A so I don't do that. What about using an external API? Ahh, damn, that could work for a short while, but I know for a fact the company is going to need B on the next month so I better do this right. Oh! But really, the problem boils down to calculating the tax return rate and I can do this easily by implementing Z! Okay, so it will take 5 minutes longer, but the return value will be far greater than doing X or Y.

Another exaggeration. But the point is that by thinking things over, by being aware of conventions, of what's happening out there, experimenting and, most importantly, using your own head to seek for solutions - not just going by the book with the rinse-and-repeat method - is so much more than writing software following the user manual or the only &ldquo;right&rdquo; way.

Think of the life of a small town physics professor and his colleague at MIT. They do the exact same thing, but one of them takes and gives far more to the job.

Code or programming in itself might not be creative in the strict sense of the word, but neither is a blank canvas. It's the idea of the artist that matters. Innovation born of experimentation is what thrives us forward. If you take the act of coding as a mundane task that can never offer you such self-satisfaction as say for an example, an architect seeing his building come to life... what good are you to the society as a whole? I could only see myself as a depressed person forced to write character after character, day after day. None of that when I have the creative freedom to dream up solutions. Then you'll see an excited geek hammering away at the keyboard.

I'll take your quote

> Software serves creative needs, development it's not creative itself, it's just functional. - K. Vaher

and use it. So when some of my fellow Developers cross me, I'll tell them to shut it, because they're "just functional", like a cogwheel in a big machine called the World.

### Parting words

It's a passionate topic of discussion. I tried to argument my reasons as best as I could and if it appeared that I only ever argued for the sake of arguing - it's not so.

There are merits in using no frameworks, there are compromises to be made between idealism and getting things done. Different people have different understandings of what's good and why - and it should be so for if there were no disagreement, we'd be a hive.

Thank you for being a worthy opponent on the bloody arena of one of the most violent wars since Linux vs. Windows.

## Kristo Vaher

Alright, for starters, frameworks vs no frameworks is not the bloodiest war since Linux vs Windows. It really is not. I absolutely love web development frameworks. I both like the heavy-handed things like Zend, which I studied when I was a young developer because everybody said it was 'the thing'. I later on loved the speed of Codeigniter and then Kohana, which I think is by far the best framework for website development out there. And I love Wordpress since even a beginner can set up quality website with custom needs there with little problems without sacrificing potential.

### Creativity Before Coding

But writing code is not a creative process. You misunderstood my point there. You should never write code out of thin air. You need to have the idea of the system and its components already in your head before writing first lines of code. You should know what is the workflow of registration system, what needs the client has and what the end system has to be able to do while at the same time staying within development budget, which is very restricted in majority of projects I've taken part of.

The creative process of software development happens before writing a single line of code. Being able to write beautiful functions and classes or having source code that looks so pretty that you'd want to make babies with it is not the goal. A developer has a duty to realize the development plan as well as possible, but 'writing code' itself is not creative. You can solve the same problem multiple ways and since the end user is unable to tell the difference, it's not a creative process since it does not benefit from being one.

This is the big difference between a software developer and a programmer. Most of the developers that have gone through in my company have been just programmers. They are not creative, they are functional. They know how to solve problems or build modules and they are working on something that has already been designed. Some programmers dabble more into designing the whole system and paying attention to usability, but it is rare. Those that do, dabble into software design, which is indeed a creative process.

### Development in Reality

As for agile development, let's speak again in a few years time when you've tried to implement it in a small company in numerous client projects without wanting to blow your brains out with a shotgun loaded with dynamite. In the end of the day it is all about the budget and agile development costs more time and money 90% of the time. There are projects where this is possible, but very few companies are willing to invest in it and even fewer clients are willing to pay for it. You have to compromise. If you have to test out and confirm every feature as it's being implemented you either have to do multiple projects at the same time or just have a client who is willing to pay a lot of money, which is very rare in Estonia in current economy.

I totally agree with your idealized vision of software development, but it is vision of software evangelists. In reality it is just not possible. There's not a single system developed that has not compromised bigtime. Facebook is being refactored even today and it is very slow to release features. Twitter refactored large parts of itself last year and is - in general - a really simplistic system. Even Google is known for refactoring (and sometimes breaking) even its own systems and they are known for writing some of the most 'beautiful' code out there. Hacks are nature of software development since getting the feature out in working condition is more important than how good it looks inside. And all of those systems share one very important need for well defined and documented API.

This returns to the point of if you are making something large, you have to design it without putting much weight on frameworks unless you are able to completely strip it to its bones and only use the essentials that are not hindrance on the end product. In general, if you begin designing something that might have thousands of active users at the same time, you really have to start from the clean sheet and then speed up the process of development by refactoring classes and methods from your pre-existing libraries. It's not the framework that developer uses that makes them valuable, but the tools they have gathered over the years. In my own example, I have an external encrypted hard drive that contains hundreds of code examples, classes and open source packages for any need that might arise without needing me to implement an entire framework.

Speed and computing power is of critical importance no matter how much computing power you have available. Worst thing that can happen to a system is to become popular and not be able to keep things running. Facebook won the battle of social networking because it implemented gradual releases in different parts of America and then later on in the world, while the big competitor Friendster attempted to bite too much at the same time and suffered with downtimes and slow service. Twitter would never have become what it is today had it suddenly developed problems with performance. While it is true that just buying more computing power could solve that problem, with large systems a more optimized and lean code can save a lot of money.

### When to Use What

And since API's (which are a must for any public system that isn't just a website or e-shop these days) benefit strongly from being just as lean, frameworks just are not good enough.

And people speaking of MVC or other software development patterns in a way as if they need a framework to be implemented perhaps have not designed MVC system themselves, because the concept behind MVC is relatively simple and can be set up by less than couple hundred lines of code with all the basics a system might need.

I strongly recommend frameworks for developing websites and e-shops and simpler info systems and I most certainly recommend studying how frameworks function since that may give better insight into MVC and other patterns than tutorials. But if speed is important you are better off implementing refactored functions and classes and build the system from ground up.

As a sidenote, in Apple vs Android battles this is also very evident. While Android is a much more flexible system than iOS, iOS implements better native code simply because of being written in Objective-C. iOS app's are simply more smooth and faster. Java is also compiled, but it is quite bloated (and there's a reason why Java frameworks are really not that well known), if not the most bloated system out there.

### Parting Thoughts

So, to summarize.. There are compromises to both sides, but the choice of going one way or another should depend entirely on the project. Of course once that decision is made, the entire team should work in unison and if project implements a framework, its standards should be followed by the entire team.

There is no right or wrong answer, but I know that if I am given a choice between two systems that are functionally exactly the same, I will prefer the faster one.

Still more to come...